<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8" />
		<title>Asteroids - Macero version</title>
		<link
			rel="stylesheet"
			type="text/css"
			target="_blank"
			href="index.css"
		/>
		<style></style>
	</head>

	<body class="page-container">
		<div class="game-container">
			<canvas
				id="gameCanvas"
				width="1000"
				height="800"
			></canvas>
		</div>
		<script>
			const FPS = 120;
			const FRICTION = 0.7; // friction coefficient of space (0 = no friction 1 = a lot of friction)
			const ASTEROIDS_NUM = 3; // starting number of asteroids
			const ASTEROIDS_JAG = 0.4; // jagegedness of asteroids (0 = no jagegedness 1 = a lot of jagegedness)
			const ASTEROIDS_SIZE = 100; // asteroid starting size in pixels
			const ASTEROIDS_SPEED = 50; // max starting speed of asteroids in pixels per second
			const ASTEROIDS_VERT = 10; // average number of verticies on each asteroid
			const SHIP_SIZE = 30; // height in pixels
			const SHIP_THRUST = 5; // acceleration of ship in pixels per second per frame
			const TURN_SPEED = 360; // turn speed in degress per second
			const SHIP_EXPLODE_DURATION = 2; // duration of ship explosion
			const SHIP_INVINCIBILITY_DURATION = 3; // duration of ship invincibility
			const SHIP_BLINK_DURATION = 0.1; // duration of blink
			const SHOW_BOUNDARIES = false; // show collision boundaries
			const SHOW_CENTER_DOT = false; // show center dot

			var canv = document.getElementById("gameCanvas");
			var ctx = canv.getContext("2d");

			// set up spaceship object
			var ship = newShip();
			// set up asteroid object
			var asteroids = [];
			createAsteroidBelt();
			var blinkOn = ship.blinkNum % 2 === 0;
			var exploding = ship.explodeTime > 0;

			const drawShip = () => {
				var blinkOn = ship.blinkNum % 2 === 0;
				exploding = ship.explodeTime > 0;
				// draw a triangular ship
				if (!exploding) {
					if (blinkOn) {
						ctx.strokeStyle = "#fff";
						ctx.lineWidth = SHIP_SIZE / 20;
						ctx.beginPath();
						ctx.moveTo(
							// nose of the ship
							ship.x + (4 / 3) * ship.r * Math.cos(ship.a),
							ship.y - (4 / 3) * ship.r * Math.sin(ship.a)
						);
						ctx.lineTo(
							// rear left
							ship.x - ship.r * ((2 / 3) * Math.cos(ship.a) + Math.sin(ship.a)),
							ship.y + ship.r * ((2 / 3) * Math.sin(ship.a) - Math.cos(ship.a))
						);
						ctx.lineTo(
							// rear right
							ship.x - ship.r * ((2 / 3) * Math.cos(ship.a) - Math.sin(ship.a)),
							ship.y + ship.r * ((2 / 3) * Math.sin(ship.a) + Math.cos(ship.a))
						);
						ctx.closePath();
						ctx.stroke();
					}

					if (ship.blinkNum > 0) {
						ship.blinkTime--;
						if (ship.blinkTime === 0) {
							ship.blinkTime = Math.ceil(SHIP_BLINK_DURATION * FPS);
							ship.blinkNum--;
						}
					}
				} else {
					//draw explosion
					ctx.fillStyle = "darkred";
					ctx.beginPath();
					ctx.arc(ship.x, ship.y, ship.r * 1.7, 0, Math.PI * 2, false);
					ctx.fill();
					ctx.fillStyle = "red";
					ctx.beginPath();
					ctx.arc(ship.x, ship.y, ship.r * 1.4, 0, Math.PI * 2, false);
					ctx.fill();
					ctx.fillStyle = "orange";
					ctx.beginPath();
					ctx.arc(ship.x, ship.y, ship.r * 1.1, 0, Math.PI * 2, false);
					ctx.fill();
					ctx.fillStyle = "yellow";
					ctx.beginPath();
					ctx.arc(ship.x, ship.y, ship.r * 0.8, 0, Math.PI * 2, false);
					ctx.fill();
					ctx.fillStyle = "white";
					ctx.beginPath();
					ctx.arc(ship.x, ship.y, ship.r * 0.5, 0, Math.PI * 2, false);
					ctx.fill();
				}

				if (SHOW_BOUNDARIES) {
					ctx.strokeStyle = "lime";
					ctx.beginPath();
					ctx.arc(ship.x, ship.y, ship.r, 0, Math.PI * 2, false);
					ctx.stroke();
				}
				if (SHOW_CENTER_DOT) {
					ctx.fillStyle = "red";
					ctx.fillRect(ship.x - 1, ship.y - 1, 2, 2);
				}
			};
			const drawShipWithThrust = () => {
				var blinkOn = ship.blinkNum % 2 === 0;
				if (!exploding && blinkOn) {
					// draw thruster
					ctx.fillStyle = "red";
					ctx.strokeStyle = "yellow";
					ctx.lineWidth = SHIP_SIZE / 10;
					ctx.beginPath();
					ctx.moveTo(
						// rear left
						ship.x - ship.r * (1 * Math.cos(ship.a) + 0.5 * Math.sin(ship.a)),
						ship.y + ship.r * (1 * Math.sin(ship.a) - 0.5 * Math.cos(ship.a))
					);
					ctx.lineTo(
						// rear center behind ship
						ship.x - ship.r * ((7 / 3) * Math.cos(ship.a)),
						ship.y + ship.r * ((7 / 3) * Math.sin(ship.a))
					);
					ctx.lineTo(
						// rear right
						ship.x - ship.r * (1 * Math.cos(ship.a) - 0.5 * Math.sin(ship.a)),
						ship.y + ship.r * (1 * Math.sin(ship.a) + 0.5 * Math.cos(ship.a))
					);
					ctx.closePath();
					ctx.fill();
					ctx.stroke();
				}
			};
			const drawBackground = () => {
				ctx.fillStyle = "#000";
				ctx.fillRect(0, 0, canv.width, canv.height);
			};
			const drawAsteroids = () => {
				var a, r, x, y, verticies, offset;

				for (var i = 0; i < asteroids.length; i++) {
					ctx.strokeStyle = "slategrey";
					ctx.lineWidth = SHIP_SIZE / 20;

					// get the asteroids properties
					a = asteroids[i].a;
					r = asteroids[i].r;
					x = asteroids[i].x;
					y = asteroids[i].y;
					verticies = asteroids[i].verticies;
					offset = asteroids[i].offset;

					ctx.beginPath();
					ctx.moveTo(
						x + r * offset[0] * Math.cos(a),
						y + r * offset[0] * Math.sin(a)
					);

					// draw a polygon
					for (j = 1; j < verticies; j++) {
						ctx.lineTo(
							x + r * offset[j] * Math.cos(a + (j * Math.PI * 2) / verticies),
							y + r * offset[j] * Math.sin(a + (j * Math.PI * 2) / verticies)
						);
					}
					ctx.closePath();
					ctx.stroke();

					if (SHOW_BOUNDARIES) {
						ctx.strokeStyle = "lime";
						ctx.beginPath();
						ctx.arc(x, y, r, 0, Math.PI * 2, false);
						ctx.stroke();
					}
				}
			};
			const handleObjectMovement = () => {
				if (!exploding) {
					ship.x += ship.thrust.x;
					ship.y += ship.thrust.y;
				}

				ship.a += ship.rot; // ship rotation

				if (ship.thrusting) {
					ship.thrust.x += (SHIP_THRUST * Math.cos(ship.a)) / FPS;
					ship.thrust.y -= (SHIP_THRUST * Math.sin(ship.a)) / FPS;
					drawShipWithThrust();
				} else {
					ship.thrust.x -= (FRICTION * ship.thrust.x) / FPS;
					ship.thrust.y -= (FRICTION * ship.thrust.y) / FPS;
				}

				for (i = 0; i < asteroids.length; i++) {
					asteroids[i].x += asteroids[i].xv;
					asteroids[i].y += asteroids[i].yv;
				}
			};
			const handleScreenEdge = () => {
				if (ship.x < 0 - ship.r) {
					ship.x = canv.width + ship.r;
				} else if (ship.x > canv.width + ship.r) {
					ship.x = 0 - ship.r;
				}
				if (ship.y < 0 - ship.r) {
					ship.y = canv.height + ship.r;
				} else if (ship.y > canv.height + ship.r) {
					ship.y = 0 - ship.r;
				}

				for (i = 0; i < asteroids.length; i++) {
					if (asteroids[i].x < 0 - asteroids[i].r) {
						asteroids[i].x = canv.width + asteroids[i].r;
					} else if (asteroids[i].x > canv.width + asteroids[i].r) {
						asteroids[i].x = 0 - asteroids[i].r;
					}
					if (asteroids[i].y < 0 - asteroids[i].r) {
						asteroids[i].y = canv.height + asteroids[i].r;
					} else if (asteroids[i].y > canv.height + asteroids[i].r) {
						asteroids[i].y = 0 - asteroids[i].r;
					}
				}
			};
			const handleCollisions = () => {
				if (!exploding) {
					if (ship.blinkNum === 0) {
						for (i = 0; i < asteroids.length; i++) {
							if (
								distBetweenPoints(ship.x, ship.y, asteroids[i].x, asteroids[i].y) <
								ship.r + asteroids[i].r
							) {
								explodeShip();
							}
						}
					}
				} else {
					ship.explodeTime--;

					if (ship.explodeTime === 0) {
						ship = newShip();
					}
				}
			};

			document.addEventListener("keydown", keyDown);
			document.addEventListener("keyup", keyUp);

			// game loop
			setInterval(update, 1000 / FPS);

			function degreeConversion(radians) {
				return ((radians / 180) * Math.PI) / FPS;
			}
			function explodeShip() {
				ship.explodeTime = Math.ceil(SHIP_EXPLODE_DURATION * FPS);
			}
			function newShip() {
				return {
					x: canv.width / 2,
					y: canv.height / 2,
					r: SHIP_SIZE / 2, //radius
					a: (90 / 180) * Math.PI, //converts to radians because Math. doesnt use angles
					explodeTime: 0,
					blinkNum: Math.ceil(SHIP_INVINCIBILITY_DURATION / SHIP_BLINK_DURATION),
					blinkTime: Math.ceil(SHIP_BLINK_DURATION * FPS),
					rot: 0,
					thrusting: false,
					thrust: {
						x: 0,
						y: 0,
					},
				};
			}
			function keyDown(e) {
				switch (e.keyCode) {
					// Movement Controls for Different Keyboard Types
					// Thrust Ship Up - Up Arrow || 'W' Key || 'I' Key
					// Rotate Ship Left - Left Arrow || 'A' Key || 'J' Key
					// Rotate Ship Right - Right Arrow || 'D' Key || 'L' Key

					// Arrow movement controls
					case 37: // Left Arrow
						ship.rot = degreeConversion(TURN_SPEED);
						break;
					case 38: // Up Arrow
						ship.thrusting = true;
						break;
					case 39: // Right Arrow
						ship.rot = degreeConversion(-TURN_SPEED);
						break;

					// WAD movement controls
					case 65: // 'A' Key
						ship.rot = degreeConversion(TURN_SPEED);
						break;
					case 87: // 'W' Key
						ship.thrusting = true;
						break;
					case 68: // 'D' Key
						ship.rot = degreeConversion(-TURN_SPEED);
						break;

					// IJL movement controls for 60% keyboards
					case 74: // 'J' Key
						ship.rot = degreeConversion(TURN_SPEED);
						break;
					case 73: // 'I' Key
						ship.thrusting = true;
						break;
					case 76: // 'L' Key
						ship.rot = degreeConversion(-TURN_SPEED);
						break;
				}
			}
			function keyUp(e) {
				switch (e.keyCode) {
					// Stop Movement for Different Keyboard Types
					// Thrust Ship Up - Up Arrow || 'W' Key || 'I' Key
					// Rotate Ship Left - Left Arrow || 'A' Key || 'J' Key
					// Rotate Ship Right - Right Arrow || 'D' Key || 'L' Key

					// Arrow movement controls
					case 37: // Left Arrow
						ship.rot = 0;
						break;
					case 38: // Up Arrow
						ship.thrusting = false;
						break;
					case 39: // Right Arrow
						ship.rot = 0;
						break;

					// WAD movement controls
					case 65: // 'A' Key
						ship.rot = 0;
						break;
					case 87: // 'W' Key
						ship.thrusting = false;
						break;
					case 68: // 'D' Key
						ship.rot = 0;
						break;

					// IJL movement controls for 60% keyboards
					case 74: // 'J' Key
						ship.rot = 0;
						break;
					case 73: // 'I' Key
						ship.thrusting = false;
						break;
					case 76: // 'L' Key
						ship.rot = 0;
						break;
				}
			}
			function createAsteroidBelt() {
				asteroids = [];
				var x, y;
				for (var i = 0; i < ASTEROIDS_NUM; i++) {
					do {
						x = Math.floor(Math.random() * canv.width);
						y = Math.floor(Math.random() * canv.height);
					} while (
						distBetweenPoints(ship.x, ship.y, x, y) <
						ASTEROIDS_SIZE * 2 + ship.r
					);
					asteroids.push(newAsteroid(x, y));
				}
			}
			function distBetweenPoints(x1, y1, x2, y2) {
				return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
			}
			function newAsteroid(x, y) {
				var asteroid = {
					a: Math.random() * Math.PI * 2, // in radians
					r: ASTEROIDS_SIZE / 2,
					verticies: Math.floor(
						Math.random() * (ASTEROIDS_VERT + 1) + ASTEROIDS_VERT / 2
					),
					x: x,
					y: y,
					xv:
						((Math.random() * ASTEROIDS_SPEED) / FPS) *
						(Math.random() < 0.5 ? 1 : -1),
					yv:
						((Math.random() * ASTEROIDS_SPEED) / FPS) *
						(Math.random() < 0.5 ? 1 : -1),
					offset: [],
				};

				for (var i = 0; i < asteroid.verticies; i++) {
					asteroid.offset.push(
						Math.random() * ASTEROIDS_JAG * 2 + 1 - ASTEROIDS_JAG
					);
				}

				return asteroid;
			}

			function update() {
				drawBackground();
				drawShip();
				drawAsteroids();
				handleObjectMovement();
				handleScreenEdge();
				handleCollisions();
			}
		</script>
	</body>
</html>
