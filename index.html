<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8" />
		<title>Asteroids - Macero version</title>
		<style></style>
	</head>

	<body
		style="
			background-color: #333;
			display: flex;
			align-items: center;
			justify-content: center;
			height: 100vh;
			width: 100vw;
		"
	>
		<canvas
			id="gameCanvas"
			width="1000"
			height="800"
		></canvas>
		<script>
			const FPS = 120;
			const FRICTION = 0.7; // friction coefficient of space (0 = no friction 1 = a lot of friction)
			const ASTEROIDS_NUM = 3; // starting number of asteroids
			const ASTEROIDS_JAG = 0.4; // jagegedness of asteroids (0 = no jagegedness 1 = a lot of jagegedness)
			const ASTEROIDS_SIZE = 100; // asteroid starting size in pixels
			const ASTEROIDS_SPEED = 50; // max starting speed of asteroids in pixels per second
			const ASTEROIDS_VERT = 10; // average number of verticies on each asteroid
			const SHIP_SIZE = 30; // height in pixels
			const SHIP_THRUST = 5; // acceleration of ship in pixels per second per frame
			const TURN_SPEED = 360; // turn speed in degress per second

			/** @type {HTMLCanvasElement} */
			var canv = document.getElementById("gameCanvas");
			var ctx = canv.getContext("2d");

			// set up spaceship object
			var ship = {
				x: canv.width / 2,
				y: canv.height / 2,
				r: SHIP_SIZE / 2, //radius
				a: (90 / 180) * Math.PI, //converts to radians because Math. doesnt use angles
				rot: 0,
				thrusting: false,
				thrust: {
					x: 0,
					y: 0,
				},
			};
			// set up asteroid object
			var asteroids = [];
			createAsteroidBelt();

			const drawShip = () => {
				// draw a triangular ship
				ctx.strokeStyle = "#fff";
				ctx.lineWidth = SHIP_SIZE / 20;
				ctx.beginPath();
				ctx.moveTo(
					// nose of the ship
					ship.x + (4 / 3) * ship.r * Math.cos(ship.a),
					ship.y - (4 / 3) * ship.r * Math.sin(ship.a)
				);
				ctx.lineTo(
					// rear left
					ship.x - ship.r * ((2 / 3) * Math.cos(ship.a) + Math.sin(ship.a)),
					ship.y + ship.r * ((2 / 3) * Math.sin(ship.a) - Math.cos(ship.a))
				);
				ctx.lineTo(
					// rear right
					ship.x - ship.r * ((2 / 3) * Math.cos(ship.a) - Math.sin(ship.a)),
					ship.y + ship.r * ((2 / 3) * Math.sin(ship.a) + Math.cos(ship.a))
				);
				ctx.closePath();
				ctx.stroke();
			};
			const drawShipWithThrust = () => {
				// draw thruster
				ctx.fillStyle = "red";
				ctx.strokeStyle = "yellow";
				ctx.lineWidth = SHIP_SIZE / 10;
				ctx.beginPath();
				ctx.moveTo(
					// rear left
					ship.x - ship.r * ((2 / 3) * Math.cos(ship.a) + 0.5 * Math.sin(ship.a)),
					ship.y + ship.r * ((2 / 3) * Math.sin(ship.a) - 0.5 * Math.cos(ship.a))
				);
				ctx.lineTo(
					// rear center behind ship
					ship.x - ship.r * ((5 / 3) * Math.cos(ship.a)),
					ship.y + ship.r * ((5 / 3) * Math.sin(ship.a))
				);
				ctx.lineTo(
					// rear right
					ship.x - ship.r * ((2 / 3) * Math.cos(ship.a) - 0.5 * Math.sin(ship.a)),
					ship.y + ship.r * ((2 / 3) * Math.sin(ship.a) + 0.5 * Math.cos(ship.a))
				);
				ctx.closePath();
				ctx.fill();
				ctx.stroke();
			};
			const drawBackground = () => {
				ctx.fillStyle = "#000";
				ctx.fillRect(0, 0, canv.width, canv.height);
			};
			const handleThrust = () => {
				if (ship.thrusting) {
					ship.thrust.x += (SHIP_THRUST * Math.cos(ship.a)) / FPS;
					ship.thrust.y -= (SHIP_THRUST * Math.sin(ship.a)) / FPS;
					drawShipWithThrust();
				} else {
					ship.thrust.x -= (FRICTION * ship.thrust.x) / FPS;
					ship.thrust.y -= (FRICTION * ship.thrust.y) / FPS;
				}
			};
			const rotateShip = () => {
				ship.a += ship.rot;
			};
			const moveShip = () => {
				ship.x += ship.thrust.x;
				ship.y += ship.thrust.y;
			};
			const handleScreenEdge = () => {
				if (ship.x < 0 - ship.r) {
					ship.x = canv.width + ship.r;
				} else if (ship.x > canv.width + ship.r) {
					ship.x = 0 - ship.r;
				}
				if (ship.y < 0 - ship.r) {
					ship.y = canv.height + ship.r;
				} else if (ship.y > canv.height + ship.r) {
					ship.y = 0 - ship.r;
				}
			};
			const drawAsteroids = () => {
				ctx.strokeStyle = "slategrey";
				ctx.lineWidth = SHIP_SIZE / 20;
				var a, r, x, y, verticies, offset;

				for (var i = 0; i < asteroids.length; i++) {
					// get the asteroids properties
					a = asteroids[i].a;
					r = asteroids[i].r;
					x = asteroids[i].x;
					y = asteroids[i].y;
					verticies = asteroids[i].verticies;
					offset = asteroids[i].offset;

					ctx.beginPath();
					ctx.moveTo(
						x + r * offset[0] * Math.cos(a),
						y + r * offset[0] * Math.sin(a)
					);

					// draw a polygon
					for (var j = 1; j < verticies; j++) {
						ctx.lineTo(
							x + r * offset[j] * Math.cos(a + (j * Math.PI * 2) / verticies),
							y + r * offset[j] * Math.sin(a + (j * Math.PI * 2) / verticies)
						);
					}
					ctx.closePath();
					ctx.stroke();

					// move the asteroid
					asteroids[i].x += asteroids[i].xv;
					asteroids[i].y += asteroids[i].yv;
					// handle edge of screen
					if (asteroids[i].x < 0 - asteroids[i].r) {
						asteroids[i].x = canv.width + asteroids[i].r;
					} else if (asteroids[i].x > canv.width + asteroids[i].r) {
						asteroids[i].x = 0 - asteroids[i].r;
					}
					if (asteroids[i].y < 0 - asteroids[i].r) {
						asteroids[i].y = canv.height + asteroids[i].r;
					} else if (asteroids[i].y > canv.height + asteroids[i].r) {
						asteroids[i].y = 0 - asteroids[i].r;
					}
				}
			};

			// setup event handlers
			document.addEventListener("keydown", keyDown);
			document.addEventListener("keyup", keyUp);

			// set up the game loop
			setInterval(update, 1000 / FPS);

			// functions
			function degreeConversion(radians) {
				return ((radians / 180) * Math.PI) / FPS;
			}
			function keyDown(e) {
				switch (e.keyCode) {
					// Movement Controls for Different Keyboard Types
					// Thrust Ship Up - Up Arrow || 'W' Key || 'I' Key
					// Rotate Ship Left - Left Arrow || 'A' Key || 'J' Key
					// Rotate Ship Right - Right Arrow || 'D' Key || 'L' Key

					// Arrow movement controls
					case 37: // Left Arrow
						ship.rot = degreeConversion(TURN_SPEED);
						break;
					case 38: // Up Arrow
						ship.thrusting = true;
						break;
					case 39: // Right Arrow
						ship.rot = degreeConversion(-TURN_SPEED);
						break;

					// WAD movement controls
					case 65: // 'A' Key
						ship.rot = degreeConversion(TURN_SPEED);
						break;
					case 87: // 'W' Key
						ship.thrusting = true;
						break;
					case 68: // 'D' Key
						ship.rot = degreeConversion(-TURN_SPEED);
						break;

					// IJL movement controls for 60% keyboards
					case 74: // 'J' Key
						ship.rot = degreeConversion(TURN_SPEED);
						break;
					case 73: // 'I' Key
						ship.thrusting = true;
						break;
					case 76: // 'L' Key
						ship.rot = degreeConversion(-TURN_SPEED);
						break;
				}
			}
			function keyUp(e) {
				switch (e.keyCode) {
					// Stop Movement for Different Keyboard Types
					// Thrust Ship Up - Up Arrow || 'W' Key || 'I' Key
					// Rotate Ship Left - Left Arrow || 'A' Key || 'J' Key
					// Rotate Ship Right - Right Arrow || 'D' Key || 'L' Key

					// Arrow movement controls
					case 37: // Left Arrow
						ship.rot = 0;
						break;
					case 38: // Up Arrow
						ship.thrusting = false;
						break;
					case 39: // Right Arrow
						ship.rot = 0;
						break;

					// WAD movement controls
					case 65: // 'A' Key
						ship.rot = 0;
						break;
					case 87: // 'W' Key
						ship.thrusting = false;
						break;
					case 68: // 'D' Key
						ship.rot = 0;
						break;

					// IJL movement controls for 60% keyboards
					case 74: // 'J' Key
						ship.rot = 0;
						break;
					case 73: // 'I' Key
						ship.thrusting = false;
						break;
					case 76: // 'L' Key
						ship.rot = 0;
						break;
				}
			}
			function createAsteroidBelt() {
				asteroids = [];
				var x, y;
				for (var i = 0; i < ASTEROIDS_NUM; i++) {
					do {
						x = Math.floor(Math.random() * canv.width);
						y = Math.floor(Math.random() * canv.height);
					} while (
						distBetweenPoints(ship.x, ship.y, x, y) <
						ASTEROIDS_SIZE * 2 + ship.r
					);
					asteroids.push(newAsteroid(x, y));
				}
			}
			function distBetweenPoints(x1, y1, x2, y2) {
				return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
			}
			function newAsteroid(x, y) {
				var asteroid = {
					a: Math.random() * Math.PI * 2, // in radians
					r: ASTEROIDS_SIZE / 2,
					verticies: Math.floor(
						Math.random() * (ASTEROIDS_VERT + 1) + ASTEROIDS_VERT / 2
					),
					x: x,
					y: y,
					xv:
						((Math.random() * ASTEROIDS_SPEED) / FPS) *
						(Math.random() < 0.5 ? 1 : -1),
					yv:
						((Math.random() * ASTEROIDS_SPEED) / FPS) *
						(Math.random() < 0.5 ? 1 : -1),
					offset: [],
				};

				for (var i = 0; i < asteroid.verticies; i++) {
					asteroid.offset.push(
						Math.random() * ASTEROIDS_JAG * 2 + 1 - ASTEROIDS_JAG
					);
				}

				return asteroid;
			}

			function update() {
				drawBackground();
				drawShip();
				drawAsteroids();
				handleThrust();
				rotateShip();
				moveShip();
				handleScreenEdge();

				// // center dot
				// ctx.fillStyle = "red";
				// ctx.fillRect(ship.x - 1, ship.y - 1, 2, 2);
			}
		</script>
	</body>
</html>
